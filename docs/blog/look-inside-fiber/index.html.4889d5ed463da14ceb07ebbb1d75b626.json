{"head":{"title":"A look inside React Fiber - how work will get done.","layout":"Post","date":"2017-07-07T15:00:00.000Z","author":"Korneliusz Caputa","description":"Describing how React Fiber operates, step by step, starting from calling the `render` function in client JS and changing state of a component, down to describing the steps taken by Fiber to do all the work. Best served with Fiber source code on the side.","tags":["react.js","javacsript","architecture"]},"body":"<p>As we all know by now, a big change is coming inside of React. <del>with version 0.16.\nIt's a significant one, because it will affect the performance of more complex\nReact applications.</del></p>\n<p><em>(EDIT: As Dan Abramov pointed out in his comment, even though 0.16 will be\nrunning on Fiber, it will run in synchronous mode, mimicking the \"traditional\"\napproach to rendering. This will not confer any changes in application behavior or\nperformance and the async Fiber APIs will not be exposed. We will reap the\nbenefits of Fiber at a later point in time. Read on nevertheless!)</em></p>\n<p>The crux of the change is transitioning from processing updates in a synchronous,\nrecursive way to relying on asynchronous scheduling and prioritization of\ninterface changes.\nThe desired result is 60 FPS and a pristine user experience.\nIt's been a while since the announcement already, and\n<a href=\"https://www.youtube.com/watch?v=aV1271hd9ew\">many good things</a>\n<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\">have been said</a>\n<a href=\"https://github.com/acdlite/react-fiber-architecture\">and written</a>.\nHowever, I like to see things for myself and understand how they work from the ground\nup. There were also a few topics that lacked \"press coverage\".</p>\n<p>Thus, down the rabbit hole I went!</p>\n<p>Fiber is not the most straightforward piece of software, both conceptually and\ncode-wise, so it should be approached in a structured way.\nThis post will go outside-in - starting from calling the <code>render</code>\nfunction in client JS and changing state of a component, down to\ndescribing the steps taken by Fiber to do all the work.\nAt a few points along the way you will be given a choice to go further down or\nreturn to the tip and track your way back to the same point from a different\norigin.</p>\n<p>If you feel like it, you can grab the Fiber codebase from Github and track your\nway through the post in the code, starting <a href=\"https://github.com/facebook/react/blob/master/src/renderers/dom/fiber/ReactDOMFiberEntry.js\">here</a>.</p>\n<p>React source code is sprinkled with a lot of error handling, dev logging and\nperformance measurement calls. I'm going to skip those and focus on the main\nlogic for the sake of clarity.</p>\n<p>Another point to note is that currently Fiber code is coupled to the DOM\nrenderer in a few places, because things are still developing, as I understand it.\nI'll try to avoid referring to it, but you can assume that \"the renderer\" means\n\"the DOM renderer\" in this post.</p>\n<p><a id=\"org882dfad\"></a></p>\n<h2 id=\"the-first-render-scratching-the-surface\"><a href=\"#the-first-render-scratching-the-surface\" class=\"phenomic-HeadingAnchor\">#</a>The first render: scratching the surface</h2>\n<p>So you have your HTML skeleton in place, relevant JS is loaded, and you hit that\nfirst <code>render</code> call. Because the page and the fiber tree is empty (there is no <code>root</code>), Fiber knows\nthat it doesn't have to worry about asynchronous processing, since nothing\nshould be happening outside of React itself.\nSo it creates a fiber instance that will represent your container as the root of\nthe fiber tree.\nThen it tells the <code>Scheduler</code> that what happens next should be considered as <code>unbatchedUpdates</code>.\nThe update in question is telling the <code>Reconciler</code> to <code>updateContainer</code>, where\nthe <code>container</code> is the root fiber that has just been created.</p>\n<p>\"Updating the container\" at this point means the following:</p>\n<ol>\n<li>\n<p><strong>Set the root fiber <code>context</code>. </strong>\nYeah, the thing that the docs tell you to avoid using.\nOverall I haven't found anything relevant to this post there.</p>\n</li>\n<li>\n<p><strong>Push an update into the update queue of the root fiber.</strong>\nThe \"bulk\" of the update is the <code>state</code>. At that moment in the <code>Scheduler</code>\ncontext it is called <code>nextState</code>, because this state is what will be\nhappening next. In the context of the update queue it is called\n<code>partialState</code>, because it will be merged with the <code>prevState</code>.\nIt is also the state you use in your React components.</p>\n<p>React's composability is nicely visible here - if you squint just a little,\nrendering your application is not much more than a glorified <code>setState</code> call.</p>\n<p>The update has a set priority level - remember that the <code>Scheduler</code> has been\ntold to do <code>unbatchedUpdates</code>? Because of that the priority level is set to\n<code>SynchronousPriority</code>. It means that this update must be done ASAP, without\nworrying about blocking the UI thread. The priority is being used to\ndetermine where in the fiber's update queue this particular update should go.\nIn this case the queue is empty, so it will be the head. Even if the queue wasn't\nempty though, it's ordered by descending priority - the update would still go\nto the front (given there are no prior <code>SynchronousPriority</code> updates there already).</p>\n</li>\n<li>\n<p><strong>Tell the <code>Scheduler</code> to schedule the update work to be done.</strong>\nThis is where the ball gets rolling.\nWhen the <code>Scheduler</code> is told to schedule an update, it looks at the\nnodes in the fiber tree, traversing it using the <code>return</code> property of each fiber.</p>\n<p> This property is pointing to a node which should be worked on next in case a\nwork phase gets interrupted (more on that later). For the sake of simplicity\nyou can assume it's the parent fiber.</p>\n<p> So the <code>Scheduler</code> goes up the tree starting from the node that the update\nshould be scheduled for, bumping up priorities where needed along the way,\nuntil it reaches the root. It can see that it's at the root, because there is\nno <code>return</code> node from it.\nIn the current case (initial render), the update has been scheduled for the\nroot node, so we're already there.</p>\n<p> Upon reaching the root, the <code>Scheduler</code> puts it in a <code>scheduledRoot</code> list\n(more about this later, that's how it later finds new work to do) and finally\nschedules the work according to given priority. In our example it's\n<code>SynchronousPriority</code>, so it jumps to the \"doing work\" phase immediately.</p>\n<p> That's all there is to <code>render</code>. The \"doing work\" phase is generic across all\nthe flows, so it's described in it's own chapter. You can go there now if you\nfeel the flow. Alternatively, you can read how Fiber arrives at this phase\nwhen you call <code>setState</code> if you need a bit more context.</p>\n</li>\n</ol>\n<p><a id=\"orgc07b371\"></a></p>\n<h2 id=\"changing-state-its-not-too-exotic\"><a href=\"#changing-state-its-not-too-exotic\" class=\"phenomic-HeadingAnchor\">#</a>Changing state: it's not too exotic</h2>\n<p>Each React component instance has an <code>updater</code>.\nThe <code>updater</code> is an injected dependency and mediates the communication between\nthe components and the React core.</p>\n<p>With Fiber, the <code>updater</code> has 4 responsibilities:</p>\n<ol>\n<li>Find a fiber instance in the tree that corresponds to this component.</li>\n<li>Ask the <code>Scheduler</code> about the priority level for this fiber.</li>\n<li>Push updates to the fiber's update queue.</li>\n<li>Schedule update work to be done with the determined priority level.</li>\n</ol>\n<p>Sounds familiar? It should, because that's almost exactly the same thing that\nhappens on render.</p>\n<p>You probably know that, but I should point out that there are two forms of arguments\nit can be called with:</p>\n<ul>\n<li><code>setState({ ... }, [callback])</code></li>\n<li><code>setState((prevState, props) => ({ ... }), [callback])</code></li>\n</ul>\n<p>It's not crucial at this point, but good for you to keep in mind as the\nfirst form will eventually become deprecated. More on that later.</p>\n<p>Ok, so you call <code>setState((prevState, props) => ({ ... }), [callback])</code>\nin your component. It tells its <code>updater</code> to enqueue a <code>setState</code>.</p>\n<p>Let's go through the 4 responsibilities.</p>\n<h3 id=\"1-find-a-fiber-instance-in-the-tree-that-corresponds-to-this-component\"><a href=\"#1-find-a-fiber-instance-in-the-tree-that-corresponds-to-this-component\" class=\"phenomic-HeadingAnchor\">#</a>1. Find a fiber instance in the tree that corresponds to this component.</h3>\n<p>   It's just getting a thing from the <code>ReactInstanceMap</code> - which is just that, a\nmap, nothing fancy. One perhaps slightly interesting thing about it is that\nit maps from public facing instances to internal methods. Example:\n</p>\n<pre><code class=\"hljs language-javascript\">get: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> key._reactInternalInstance;\n},</code></pre>\n<h3 id=\"2-ask-the-scheduler-about-the-priority-level-for-this-fiber\"><a href=\"#2-ask-the-scheduler-about-the-priority-level-for-this-fiber\" class=\"phenomic-HeadingAnchor\">#</a>2. Ask the <code>Scheduler</code> about the priority level for this fiber.</h3>\n<p>   There is a <code>Scheduler</code> method called <code>getPriorityContext</code> that provides a\nsuitable priority level for a fiber update. For all intents and purposes,\nthe priority level for a <code>setState</code> will be <code>LowPriority</code>. Refer to the\nglossary to see how that priority level stacks up against the others.</p>\n<p>   <em>There are 2 edge cases to this, but you shouldn't concern yourself with\nthem too much.\nIf you're studying for a test and must know, they are:\nexplicitly passing a <code>useSyncScheduling: true</code> parameter to the context getting\nfunction, which will result in <code>SynchronousPriority</code>; and having\n<code>priorityContext</code> of <code>SynchronousPriority</code> during the work phase or a\n<code>batchedUpdates</code> callback - which will result in <code>TaskPriority</code>.</em></p>\n<h3 id=\"3-push-updates-to-the-fibers-update-queue\"><a href=\"#3-push-updates-to-the-fibers-update-queue\" class=\"phenomic-HeadingAnchor\">#</a>3. Push updates to the fiber's update queue.</h3>\n<p>   This logic is pretty much the same as in the initial render case. The only\ndifferences are that:</p>\n<ul>\n<li><code>setState</code> is not a top-level update, so the code doesn't check if the\nupdate is a top-level unmount.</li>\n<li>the priority level is lower (<code>LowPriority</code>).</li>\n</ul>\n<p>   The new update is being inserted to the fiber's update queue according to the\npriority level - so most likely it will get added to the end of the queue.</p>\n<h3 id=\"4-schedule-update-work-to-be-done-with-the-determined-priority-level\"><a href=\"#4-schedule-update-work-to-be-done-with-the-determined-priority-level\" class=\"phenomic-HeadingAnchor\">#</a>4. Schedule update work to be done with the determined priority level.</h3>\n<p>   As I've mentioned before, this logic is generic across all the flows - so\nnothing changes here in terms of walking the tree. To reiterate, Fiber walks\nthe <code>return</code> nodes starting from the node for which the update is being\nscheduled until it reaches the root node (whose <code>return</code> is <code>null</code>). Along\nthe way, it bumps up the <code>pendingWorkPriority</code> of each node to the currently\ngiven level if it's lower. In this case the level is <code>LowPriority</code> so it's\nnot likely for too many changes in the <code>pendingWorkPriority</code> values to occur.</p>\n<p>   After reaching the root, Fiber schedules the update work - due to\n<code>LowPriority</code> it's scheduled with <code>requestIdleCallback</code>.\nThat brings us to the end of the <code>setState</code> flow.\nThe logic exits and when time comes, the work phase begins.</p>\n<p><a id=\"org13b502a\"></a></p>\n<h2 id=\"doing-the-work-show-me-the-money\"><a href=\"#doing-the-work-show-me-the-money\" class=\"phenomic-HeadingAnchor\">#</a>Doing the work: show me the money</h2>\n<blockquote>\n<p>Ahh, you're here. Good. We've got a problem. A big one.</p>\n<p>– <cite>The Overseer, Vault 13</cite></p>\n</blockquote>\n<p>Well, not really. ;) Or not so much anymore at least, having asynchronous work\nscheduling on our side!\nThat said though, you might want to take a breath/coffee/stretch before this one - this is the\nmeat and potatoes of Fiber and might get a bit dense.</p>\n<p>The actual execution of the scheduled work is split up in 2 main phases:\nrender/reconciliation and commit.</p>\n<p>Let's jump in.</p>\n<p><a id=\"orga27f81c\"></a></p>\n<h3 id=\"render--reconciliation\"><a href=\"#render--reconciliation\" class=\"phenomic-HeadingAnchor\">#</a>Render / reconciliation.</h3>\n<p>This phase happens within the fiber tree and thus can be interrupted.\nNo DOM interaction takes place here yet. This is one of the big wins and differentiating factors from the traditional\nrenderer.\nAs the code can rely on the <code>deadline</code> value provided by\n<code>requestIdleCallback</code>, it can split the work in time to avoid busting UI frames.</p>\n<p>During this phase, Fiber aggregates the updates building up a second,\n<code>workInProgress</code> copy of the fiber tree, which is the <code>alternate</code> of the\n<code>current</code> tree. The <code>current</code> tree is the one that is flushed to the DOM at\nthe given moment.</p>\n<p>Each of the flows described previously stopped at the phase where the work\nwas to be executed immediately (for <code>SynchronousPriority</code>) or scheduled with\nan async callback request function.</p>\n<p>The function that is being called or scheduled at that point is <code>performWork</code>.\nIts purpose is to catch and handle errors happening during the reconciliation of the\nupdates and building up the tree. It does it by running a <code>while</code> loop that\nbails out in case of errors. Within this loop, the <code>workLoop</code> function\nis being called.</p>\n<p>We're here. The core of the nuclear reactor.</p>\n<p><code>workLoop</code> finds a fiber to work on, which consists of looking through the\n<code>scheduledRoot</code> list (that's where the top-level updates go, remember?) for\nthe highest priority root fiber.</p>\n<p>Then, it checks whether a <code>deadline</code> exists and whether the current priority\nof work is lower than <code>TaskPriority</code>, meaning that the execution of this work\nmust obey the time limitations of the current frame.\nIf there is no <code>deadline</code> or the priority is high enough then it runs a normal\n<code>while</code> loop until it can find no more work to do.</p>\n<p>If a <code>deadline</code> exists however (or the priority is low), then it runs a <code>while</code>\nloop until there is work to be done and the <code>deadline</code> hasn't yet expired.\nAs long as that conditions hold, in terms of Fiber <strong>we are in a deferred batch</strong>.\n(again, any bells ringing? <code>batchedUpdates</code> way back when I was describing <code>render</code>?)\n<span class=\"underline\">This is where the decision is being made to either carry on with processing the\nfibers or to defer the processing to the next frame to avoid causing jank in the UI.</span></p>\n<p>Here, the current unit of work is being <em>performed</em>.\nPerforming the work is a process consisting of two stages: <code>begin</code> and <code>complete</code>.</p>\n<h4 id=\"stage-1-beginning-the-work\"><a href=\"#stage-1-beginning-the-work\" class=\"phenomic-HeadingAnchor\">#</a>Stage 1: beginning the work</h4>\n<p>When the work is \"being begun\", the code checks whether the priority of\nthe work-in-progress fiber is high enough to be processed given the priority at\nwhich work is currently supposed to be processed and bails out if it's not.</p>\n<p>Beginning the work encompasses a lot of things, which I think are out of scope\nsince we're deep enough and they would take <strong>a lot</strong> of space to describe.\nIn short, what happens here depends on the work-in-progress fiber type, and is\nhandled by a big <code>switch</code> statement:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">switch</span> (workInProgress.tag) {\n  <span class=\"hljs-keyword\">case</span> IndeterminateComponent:\n    <span class=\"hljs-keyword\">return</span> mountIndeterminateComponent(\n      current,\n      workInProgress,\n      priorityLevel,\n    );\n  <span class=\"hljs-keyword\">case</span> FunctionalComponent:\n    <span class=\"hljs-keyword\">return</span> updateFunctionalComponent(current, workInProgress);\n  <span class=\"hljs-keyword\">case</span> ClassComponent:\n    <span class=\"hljs-keyword\">return</span> updateClassComponent(current, workInProgress, priorityLevel);\n  <span class=\"hljs-keyword\">case</span> HostRoot:\n    <span class=\"hljs-keyword\">return</span> updateHostRoot(current, workInProgress, priorityLevel);\n  <span class=\"hljs-keyword\">case</span> HostComponent:\n    <span class=\"hljs-keyword\">return</span> updateHostComponent(current, workInProgress);\n  <span class=\"hljs-keyword\">case</span> HostText:\n    <span class=\"hljs-keyword\">return</span> updateHostText(current, workInProgress);\n  <span class=\"hljs-keyword\">case</span> CoroutineHandlerPhase:\n    <span class=\"hljs-comment\">// This is a restart. Reset the tag to the initial phase.</span>\n    workInProgress.tag = CoroutineComponent;\n  <span class=\"hljs-comment\">// Intentionally fall through since this is now the same.</span>\n  <span class=\"hljs-keyword\">case</span> CoroutineComponent:\n    <span class=\"hljs-keyword\">return</span> updateCoroutineComponent(current, workInProgress);\n  <span class=\"hljs-keyword\">case</span> YieldComponent:\n    <span class=\"hljs-comment\">// A yield component is just a placeholder, we can just run through the</span>\n    <span class=\"hljs-comment\">// next one immediately.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">case</span> HostPortal:\n    <span class=\"hljs-keyword\">return</span> updatePortalComponent(current, workInProgress);\n  <span class=\"hljs-keyword\">case</span> Fragment:\n    <span class=\"hljs-keyword\">return</span> updateFragment(current, workInProgress);\n  <span class=\"hljs-keyword\">default</span>:\n    invariant(\n      <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-string\">'Unknown unit of work tag. This error is likely caused by a bug in '</span> +\n        <span class=\"hljs-string\">'React. Please file an issue.'</span>,\n    );\n}</code></pre>\n<p>The following, however, is crucial:</p>\n<ul>\n<li>Those <code>update</code> functions merge component states with the <code>pendingState</code> values\nand memoize them, update children's props and perform reconciliation on subtrees.</li>\n<li>Each change performed on the node's subtree causes it to be tagged with a\nspecific <strong>effect tag</strong>, meaning that a side-effect shall be executed on it.\nYou can refer to the glossary to see all the effect tags - in this phase, the\nonly tags that are being used are <code>ContentReset</code>, <code>Err</code>, <code>Placement</code> and <code>Ref</code>.</li>\n<li>The <code>update</code> functions return return <code>null</code> if the element is a leaf of the\nfiber tree, or return the child fiber if it has one. When they return the\nchild fiber, we say that the <strong>beginning the work on this fiber has spawned new work</strong>.</li>\n</ul>\n<p>If beginning the work on a fiber hasn's spawned any new work, a function is\ncalled that starts <em>completing the work</em> (stage 2) on the the work-in-progress fiber.\nIf new work has been spawned, control is returned to <code>workLoop</code>.\nIt marks this new work as the <code>nextUnitOfWork</code> to be processed in the next\nturn of the time-constraining <code>while</code> loop.\n<span class=\"underline\">This is how the decision is being made to either carry on with processing the\nfibers or to defer the processing to the next frame to avoid causing jank in the UI.</span></p>\n<h4 id=\"stage-2-completing-the-work\"><a href=\"#stage-2-completing-the-work\" class=\"phenomic-HeadingAnchor\">#</a>Stage 2: completing the work</h4>\n<p>When beginning a unit of work hasn't spawned any new work, we are at a leaf of\nthe fiber tree. In this case the code will complete the work for the current\nbranch.\nCompleting the work operates in a <code>while</code> loop that stops upon\nfinding a <code>sibling</code> fiber (which gets returned to <code>workLoop</code>) or reaching the\nroot of the tree (which prompts the <em>commit phase</em>).\nThe process consists of 4 steps:</p>\n<ol>\n<li>\n<p><strong>Reset the fiber's priority.</strong></p>\n</li>\n<li>\n<p><strong>Set update information.</strong></p>\n<p>Depending on the type of fiber being completed it may mean:</p>\n<ul>\n<li>setting the new <code>context</code> on the root fiber,</li>\n<li>adding an <code>Update</code> tag to the fiber's <code>effectTag</code>, calculating the update payload\n(i.e. new props) and adding it to the fiber's <code>updateQueue</code>,</li>\n<li>adding a <code>Ref</code> tag to the fiber's <code>effectTag</code> if a <code>ref</code> was defined on the\ncomponent.</li>\n</ul>\n</li>\n<li>\n<p><strong>Build up the effect lists up the fiber branch.</strong></p>\n<p>If the work-in-progress fiber has a <code>return</code> fiber and an <code>effectTag</code> value\ndifferent than <code>NoEffect</code>, it will first append all the side effects from its\neffect list to the <code>return</code> fiber's list and then append itself to it.\nThe result is that each fiber's effect list is an ordered collection\nof its child subtree's side effects, ended by its own. It's ordered by the\ncompletion order of the children.</p>\n</li>\n<li>\n<p><strong>Traverse the tree further.</strong></p>\n<p>If the work-in-progress fiber has a <code>sibling</code> fiber, it is returned to the\n<code>workLoop</code> to make a decision whether to start processing it in this frame or\nto defer it to the next one.\n<span class=\"underline\">A <code>sibling</code> fiber is the result of returning an array of elements from a\n<code>render</code> function, that's one of the new features in Fiber.</span></p>\n<p>If there is no <code>sibling</code>, but a <code>return</code> fiber exists, then it is set to be\nprocessed in the next turn of the completion stage's <code>while</code> loop.</p>\n<p>If the work-in-progress fiber doesn't have a <code>return</code> or a <code>sibling</code> fiber,\nit means that we have reached the root of the fiber tree.</p>\n<p>If the <code>nextPriorityLevel</code> is <code>SynchronousPriority</code> or <code>TaskPriority</code>, it\nmeans that the work that has just been completed is related to a scheduled\nroot and also that it has not been scheduled with an async callback request.\nIn that case, the code immediately begins the commit phase by calling\n<code>commitAllWork(workInProgress)</code>.\nOtherwise, when the priority is lower (i.e. work belongs to a\ndeferred batch), the work-in-progress is being set as a <code>pendingCommit</code>. The\n<code>workLoop</code> will decide when to commit the work in the <code>pendingCommit</code> based\non how much time is left in the frame.</p>\n</li>\n</ol>\n<p>That's it for this stage. The result of completing a unit of work (fiber) is\neither entering the commit phase immediately or having a non-null <code>pendingBatch</code>.</p>\n<p>The commit phase will be described in the next chapter.</p>\n<p>I'll close off the render/reconciliation phase description by pointing out that the\n<code>workLoop</code> checks for the existence of a <code>pendingBatch</code> and if there is enough\ntime within the current frame, it calls <code>commitAllWork(pendingBatch)</code>, thus\nentering the commit phase.</p>\n<p><a id=\"org2ca3fb6\"></a></p>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"phenomic-HeadingAnchor\">#</a>Commit</h3>\n<p>This is where the contents of the work-in-progress fiber tree get flushed to the\nDOM - in other words, this is when all the side effects from the fiber tree get executed.\nThis phase is not designed to be interruptible, since otherwise it would open up\npossibilities for inconsistent \"in-between\" UI states.\nIt is being achieved by setting a priority level <code>TaskPriority</code> for the whole\ntime of the phase.\nThe previous priority level is being stowed away as <code>previousPriorityContext</code>.</p>\n<p>The entry point for committing the work is the <code>commitAllWork</code> function.</p>\n<p>Before starting going through the effect list of the fiber tree, it checks if\nthe root fiber has an <code>effectTag</code> on it too.\n<em>(This is because during the completion phase, the <code>effectTag</code> was being added to the\n<code>return</code> fiber's effect list.\nThere is no <code>return</code> fiber for the root of the tree, hence it is done here afterwards.)</em></p>\n<p>The commit process consists of two passes through the whole effect list of the fiber tree.</p>\n<p>The first pass does DOM manipulation (placement, updates, deletions) using the\ninjected renderer and unmounts <code>ref</code> functions.</p>\n<p>After the first pass, Fiber swaps the work-in-progress tree with the <code>current</code>\none. That's because the work-in-progress one just got flushed to the DOM, so\nconceptually it became the <code>current</code>.</p>\n<p>The second pass calls lifecycle hooks, <code>setState</code> callbacks, <code>ref</code> callbacks\nand component-level error handling methods (new feature in Fiber!).</p>\n<p>After the second pass (and some housekeeping), the priority level from before\nthe commit ie restored from <code>previousPriorityContext</code>.</p>\n<p><a id=\"org3c31b83\"></a></p>\n<h2 id=\"thats-all-folks\"><a href=\"#thats-all-folks\" class=\"phenomic-HeadingAnchor\">#</a>That's all, folks!</h2>\n<p>With sufficient squinting and skipping over ancillary details, we have drilled\nthrough the main features of React Fiber, from the first client <code>render</code> call, down to\nthe nitty-gritty of scheduling and splitting the work into phases.</p>\n<p>If you didn't have the Fiber codebase handy while reading this, it might be\ninteresting for you to go grab it and read through this post again - this time\ntracking your steps through the code. You'll see that even though there is quite\na few cogs in the machine of Fiber, it is way less complicated than you'd expect.</p>\n<p>If you see any mistakes or omissions, feel free to point them out!\nI'll amend the post.</p>\n<p>I did my best to skip over aspects that were not key to the main responsibility\nof Fiber.\nBut a few of them are very interesting in themselves, or are used in an\ninteresting way, for example:</p>\n<ul>\n<li>Component-level error handling, error boundaries</li>\n<li>The use of object pooling</li>\n<li>Dependency injection</li>\n</ul>\n<p>There might be another post coming, which will describe those things, so stay tuned!</p>\n<p>And lastly, the obligatory wafting paragraph. It's good to <em>actually know</em> how\nthe tools you use every day work. Of course it's not always possible or sensible\nto look at everything - but the perspective, sense of confidence and\nsatisfaction gained from this type of activity is significant.\nYou have to read a lot to become a great writer. I think programmers are no\ndifferent - and JavaScript fatigue, the state of Web development, Angular 4,\nReact 16 or Webpack 3 should not serve as an excuse to neglect this practice.</p>\n<p>As craftspeople, we need to study the tools we use and other people's\ncraft we see around us to improve our own and perhaps eventually surpass it.</p>\n<p><a id=\"org7cd8bdd\"></a></p>\n<h2 id=\"glossary-types-and-constants\"><a href=\"#glossary-types-and-constants\" class=\"phenomic-HeadingAnchor\">#</a>Glossary: types and constants</h2>\n<p>Here are some important types and constants used in the Fiber codebase.\nI'm not putting them at the top to allow you to jump right into the interesting\nstuff without having to waddle through a bunch of things that don't make sense\nout of context.</p>\n<p><a id=\"org8c13c72\"></a></p>\n<h3 id=\"update\"><a href=\"#update\" class=\"phenomic-HeadingAnchor\">#</a>Update</h3>\n<p>An <code>Update</code> looks like this:</p>\n<pre><code class=\"hljs language-javascript\">type Update = {\n  <span class=\"hljs-attr\">priorityLevel</span>: PriorityLevel,\n  <span class=\"hljs-attr\">partialState</span>: PartialState&#x3C;any, any>,\n  <span class=\"hljs-attr\">callback</span>: Callback | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">isReplace</span>: boolean,\n  <span class=\"hljs-attr\">isForced</span>: boolean,\n  <span class=\"hljs-attr\">isTopLevelUnmount</span>: boolean,\n  <span class=\"hljs-attr\">next</span>: Update | <span class=\"hljs-literal\">null</span>,\n};</code></pre>\n<p>Where <code>PartialState</code> is what you pass into <code>setState</code>: either an object or a\n<code>(prevState, props) => partialState</code> function.</p>\n<p><a id=\"org4c0e3af\"></a></p>\n<h3 id=\"update-queue\"><a href=\"#update-queue\" class=\"phenomic-HeadingAnchor\">#</a>Update queue</h3>\n<p>A fiber's update queue looks like this:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">export</span> type UpdateQueue = {\n  <span class=\"hljs-attr\">first</span>: Update | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">last</span>: Update | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">hasForceUpdate</span>: boolean,\n  <span class=\"hljs-attr\">callbackList</span>: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-built_in\">Array</span>&#x3C;Callback>,\n};</code></pre>\n<p>The <code>callbackList</code> holds the <code>callback</code> values you passed in to\n<code>setState(stateUpdater, [callback])</code>, if any.</p>\n<p><a id=\"orgdd96006\"></a></p>\n<h3 id=\"priority-levels\"><a href=\"#priority-levels\" class=\"phenomic-HeadingAnchor\">#</a>Priority levels</h3>\n<pre><code class=\"hljs language-javascript\">type PriorityLevel = <span class=\"hljs-number\">0</span> | <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span> | <span class=\"hljs-number\">6</span>;\n\nNoWork: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// No work is pending.</span>\nSynchronousPriority: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// For controlled text inputs. Synchronous side-effects.</span>\nTaskPriority: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// Completes at the end of the current tick.</span>\nAnimationPriority: <span class=\"hljs-number\">3</span>, <span class=\"hljs-comment\">// Needs to complete before the next frame.</span>\nHighPriority: <span class=\"hljs-number\">4</span>, <span class=\"hljs-comment\">// Interaction that needs to complete pretty soon to feel responsive.</span>\nLowPriority: <span class=\"hljs-number\">5</span>, <span class=\"hljs-comment\">// Data fetching, or result from updating stores.</span>\nOffscreenPriority: <span class=\"hljs-number\">6</span>, <span class=\"hljs-comment\">// Won't be visible but do the work in case it becomes visible.</span></code></pre>\n<p>When Fiber schedules work, <code>SynchronousWork</code> is scheduled immediately on the UI\nthread, <code>AnimationPriority</code> is scheduled with <code>requestAnimationFrame</code> and the\nlower priorities with <code>requestIdleCallback</code>.</p>\n<p>Whenever \"higher/highest priority level\" is being mentioned, there is always an asterisk: \"except\nfor <code>NoWork</code>\".\nThe code always checks for that priority level separately.</p>\n<p><a id=\"org4ecef3c\"></a></p>\n<h3 id=\"side-effect-tags-types-of-side-effects\"><a href=\"#side-effect-tags-types-of-side-effects\" class=\"phenomic-HeadingAnchor\">#</a>Side effect tags (types of side effects)</h3>\n<pre><code class=\"hljs language-javascript\">type TypeOfSideEffect = number\n\nNoEffect: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">//           0b0000000</span>\nPlacement: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">//          0b0000001</span>\nUpdate: <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">//             0b0000010</span>\nPlacementAndUpdate: <span class=\"hljs-number\">3</span>, <span class=\"hljs-comment\">// 0b0000011</span>\nDeletion: <span class=\"hljs-number\">4</span>, <span class=\"hljs-comment\">//           0b0000100</span>\nContentReset: <span class=\"hljs-number\">8</span>, <span class=\"hljs-comment\">//       0b0001000</span>\nCallback: <span class=\"hljs-number\">16</span>, <span class=\"hljs-comment\">//          0b0010000</span>\nErr: <span class=\"hljs-number\">32</span>, <span class=\"hljs-comment\">//               0b0100000</span>\nRef: <span class=\"hljs-number\">64</span>, <span class=\"hljs-comment\">//               0b1000000</span></code></pre>\n<p>Having the tags defined like this allows using the binary operations in a handy\nway. (I mean adding new tags by <code>effectTag |= Placement</code>, removing them\nwith <code>effectTag &#x26;= ~Placement</code> etc.)</p>\n<p><a id=\"orgdd07bda\"></a></p>\n<h3 id=\"fiber-vs-fiber\"><a href=\"#fiber-vs-fiber\" class=\"phenomic-HeadingAnchor\">#</a>Fiber vs fiber</h3>\n<p>Whenever I refer to Fiber with a capital F, I mean React Fiber, the new reconciler.\nWhenever I refer to a fiber with a lowercase f, I mean the data structure\nrepresenting the basic unit of work related to a React component.\nThe data structure like this (I'm leaving most of Facebook's comments as\nthey're very good):</p>\n<pre><code class=\"hljs language-javascript\">type Fiber = {\n  <span class=\"hljs-comment\">// These fields conceptually belong to an instance of the component</span>\n  <span class=\"hljs-comment\">// this fiber is related to.</span>\n\n  <span class=\"hljs-comment\">// Tag identifying the type of fiber.</span>\n  tag: TypeOfWork,\n\n  <span class=\"hljs-comment\">// Unique identifier of this child.</span>\n  key: <span class=\"hljs-literal\">null</span> | string,\n\n  <span class=\"hljs-comment\">// The function/class/module associated with this fiber.</span>\n  type: any,\n\n  <span class=\"hljs-comment\">// The local state associated with this fiber.</span>\n  stateNode: any,\n\n  <span class=\"hljs-comment\">// Remaining fields belong to Fiber</span>\n\n  <span class=\"hljs-comment\">// The Fiber to return to after finishing processing this one.</span>\n  <span class=\"hljs-comment\">// This is effectively the parent, but there can be multiple parents (two)</span>\n  <span class=\"hljs-comment\">// so this is only the parent of the thing we're currently processing.</span>\n  <span class=\"hljs-comment\">// It is conceptually the same as the return address of a stack frame.</span>\n  <span class=\"hljs-keyword\">return</span>: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// Singly Linked List Tree Structure.</span>\n  child: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">sibling</span>: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">index</span>: number,\n\n  <span class=\"hljs-comment\">// The ref last used to attach this node.</span>\n  <span class=\"hljs-comment\">// I'll avoid adding an owner field for prod and model that as functions.</span>\n  ref: <span class=\"hljs-literal\">null</span> | <span class=\"hljs-function\">(<span class=\"hljs-params\">((handle: mixed</span>) =></span> <span class=\"hljs-keyword\">void</span>) &#x26; {<span class=\"hljs-attr\">_stringRef</span>: ?string}),\n\n  <span class=\"hljs-comment\">// Input is the data coming into process this fiber. Arguments. Props.</span>\n  pendingProps: any, <span class=\"hljs-comment\">// This type will be more specific once we overload the tag.</span>\n  memoizedProps: any, <span class=\"hljs-comment\">// The props used to create the output.</span>\n\n  <span class=\"hljs-comment\">// A queue of state updates and callbacks.</span>\n  updateQueue: UpdateQueue | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// The state used to create the output</span>\n  memoizedState: any,\n\n  <span class=\"hljs-comment\">// Bitfield that describes properties about the fiber and its subtree. E.g.</span>\n  <span class=\"hljs-comment\">// the AsyncUpdates flag indicates whether the subtree should be async-by-</span>\n  <span class=\"hljs-comment\">// default. When a fiber is created, it inherits the internalContextTag of its</span>\n  <span class=\"hljs-comment\">// parent. Additional flags can be set at creation time, but after than the</span>\n  <span class=\"hljs-comment\">// value should remain unchanged throughout the fiber's lifetime, particularly</span>\n  <span class=\"hljs-comment\">// before its child fibers are created.</span>\n  internalContextTag: TypeOfInternalContext,\n\n  <span class=\"hljs-comment\">// Effect</span>\n  effectTag: TypeOfSideEffect,\n\n  <span class=\"hljs-comment\">// Singly linked list fast path to the next fiber with side-effects.</span>\n  nextEffect: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// The first and last fiber with side-effect within this subtree. This allows</span>\n  <span class=\"hljs-comment\">// us to reuse a slice of the linked list when we reuse the work done within</span>\n  <span class=\"hljs-comment\">// this fiber.</span>\n  firstEffect: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">lastEffect</span>: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// This will be used to quickly determine if a subtree has no pending changes.</span>\n  pendingWorkPriority: PriorityLevel,\n\n  <span class=\"hljs-comment\">// This value represents the priority level that was last used to process this</span>\n  <span class=\"hljs-comment\">// component. This indicates whether it is better to continue from the</span>\n  <span class=\"hljs-comment\">// progressed work or if it is better to continue from the current state.</span>\n  progressedPriority: PriorityLevel,\n\n  <span class=\"hljs-comment\">// If work bails out on a Fiber that already had some work started at a lower</span>\n  <span class=\"hljs-comment\">// priority, then we need to store the progressed work somewhere. This holds</span>\n  <span class=\"hljs-comment\">// the started child set until we need to get back to working on it. It may</span>\n  <span class=\"hljs-comment\">// or may not be the same as the \"current\" child.</span>\n  progressedChild: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// When we reconcile children onto progressedChild it is possible that we have</span>\n  <span class=\"hljs-comment\">// to delete some child fibers. We need to keep track of this side-effects so</span>\n  <span class=\"hljs-comment\">// that if we continue later on, we have to include those effects. Deletions</span>\n  <span class=\"hljs-comment\">// are added in the reverse order from sibling pointers.</span>\n  progressedFirstDeletion: Fiber | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">progressedLastDeletion</span>: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// This is a pooled version of a Fiber. Every fiber that gets updated will</span>\n  <span class=\"hljs-comment\">// eventually have a pair. There are cases when we can clean up pairs to save</span>\n  <span class=\"hljs-comment\">// memory if we need to.</span>\n  alternate: Fiber | <span class=\"hljs-literal\">null</span>,\n\n  <span class=\"hljs-comment\">// Conceptual aliases</span>\n  <span class=\"hljs-comment\">// workInProgress : Fiber ->  alternate The alternate used for reuse happens</span>\n  <span class=\"hljs-comment\">// to be the same as work in progress.</span>\n};</code></pre>\n<p><a id=\"orgab66cc2\"></a></p>\n","__filename":"blog/look-inside-fiber.md","__url":"/blog/look-inside-fiber/","__resourceUrl":"/blog/look-inside-fiber/index.html","__dataUrl":"/blog/look-inside-fiber/index.html.4889d5ed463da14ceb07ebbb1d75b626.json"}